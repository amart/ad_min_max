%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.3 (9/9/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[oneside]{article}

\usepackage{lipsum} % Package to generate dummy text throughout this template
\usepackage{sectsty}
\sectionfont{\bfseries\Large\raggedright}
\usepackage[printwatermark]{xwatermark}
\newwatermark[allpages,color=red!50,angle=45,scale=3,xpos=0,ypos=0]{DRAFT}
\usepackage{makecell}
\usepackage{pgfplots}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linktoc=all,
    citecolor=blue,
    filecolor=blue,
    linkcolor=blue,
    urlcolor=blue
}
\usepackage{titlesec}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{forest}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{adjustbox}

\newsavebox{\mysavebox}
\newlength{\myrest}
\usepackage{fix-cm}
\usepackage{algorithm,algpseudocode,float}
\usepackage{lipsum}
\newcommand{\Code}[1]{%
\lstinline{#1}}
\usepackage[T1]{fontenc}
\usepackage[many]{tcolorbox}
\tcbuselibrary{listings}

\newcommand{\Out}[1]{%
\begin{lstlisting}[language=bash]
#1
\end{lstlisting}
}
\newtcblisting{cppsource}{
  colback=white,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  top=0pt,
  bottom=0pt,
  colframe=white,
  listing only,
 left=15.5pt,
  enhanced,
  listing options={
    columns=flexible,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{blue},
    backgroundcolor=\color{black!4}, % set backgroundcolor
    language=C++,
    showstringspaces=false,
    tabsize=2,
  }
}
\newtcblisting{smallcppsource}{
  colback=white,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  top=0pt,
  bottom=0pt,
  colframe=white,
  listing only,
 left=15.5pt,
  enhanced,
  listing options={
    columns=flexible,
    basicstyle=\tiny\ttfamily,
    keywordstyle=\color{blue},
    backgroundcolor=\color{black!4}, % set backgroundcolor
    language=C++,
    showstringspaces=false,
    tabsize=2,
  }
}

\newtcblisting{myoutput}{
  colback=white,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  top=0pt,
  bottom=0pt,
  colframe=white,
  listing only,
  listing options={
    basicstyle=\scriptsize\ttfamily\color{black},
    breaklines=false,
    columns=flexible,
     backgroundcolor=\color{white}, % set backgroundcolor
%    language=bash,
  }
}


\newtcblisting{editnote}{
  colback=white,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  top=0pt,
  bottom=0pt,
  colframe=white,
  listing only,
  listing options={
    basicstyle=\scriptsize\ttfamily,
    breaklines=false,
    columns=flexible,
     backgroundcolor=\color{white}, % set backgroundcolor
    language=bash,
  }
}

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
%\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
%\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
%\fancyhead{} % Blank out the default header
%\fancyfoot{} % Blank out the default footer
%\fancyhead[C]{Some Journal $\bullet$ August 2016 $\bullet$ Vol. XXI, No. 1} % Custom header text
%\fancyfoot[RO,LE]{\thepage} % Custom footer text



%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\vspace{-15mm}\fontsize{24pt}{24pt}\selectfont\textbf{Notes On \protect\\  Implementing Differentiable  \protect\\ Minimum And Maximum Functions \protect\\
In \protect\\
ATL and  ADMB}} % Article title

\author{
\large
\textsc{Matthew R. Supernaw}\\[2mm] % Your name
\normalsize National Oceanic Atmospheric Administration \\ % Your institution
\normalsize National Marine Fisheries Service, Office of Science and Technology\\ % Your institution
\normalsize \href{mailto:matthew.supernaw@noaa.gov}{matthew.supernaw@noaa.gov} \\ % Your email address
\\
\textsc{Z. Teresa A'mar, PhD}\\[2mm] % Your name
\normalsize National Oceanic Atmospheric Administration \\ % Your institution
\normalsize National Marine Fisheries Service, Office of Science and Technology\\ % Your institution
\normalsize \href{mailto:teresa.amar@noaa.gov}{teresa.amar@noaa.gov} \\% Your email address
\vspace{-5mm}
}
\date{}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Insert title

\thispagestyle{fancy} % All pages have headers and footers

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

%\begin{abstract}
%
%\noindent
%
%
%\end{abstract}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\newpage
\tableofcontents
\newpage

\section{Introduction}

The "minimum" and "maximum" functions (usually written as \textit{min(a,b)} and \textit{max(a,b)}, respectively) are problematic for automatic differentiation systems. The issue is that existing \textit{min()} and \textit{max()} function implementations rely on conditional statements, or branches, to calculate the return value. This method results in a piecewise continuous function which is not generally differentiable.  In this paper we describe a method so that the \textit{min()} and \textit{max()} functions with two automatic differentiation variable types as arguments can be calculated with no branching, thereby preserving the derivatives of the variables. In addition, we describe how these functions can be implemented in ATL, ADMB, and TMB.


\section{Methods}

Given two variables \textit{a} and \textit{b}, calculate the minimum or maximum value. Existing implementations involve conditional operations, i.e., "if" statements are used to determine the return value:

\begin{cppsource}
template<typename T>
T min(const T& a, const T& b){
   return a < b ? a : b;
}

template<typename T>
T max(const T& a, const T& b){
   return a > b ? a : b;
}

\end{cppsource}

These functions do not work in an automatic differentiation system since the functions are not differentiable everywhere given the branching in the code.

A common branchless alternative can be used:

\begin{cppsource}
template<typename T>
T min(const T& a, const T& b){
   return (a + b - fabs(a - b)) / 2.0;
}

template<typename T>
T max(const T& a, const T& b){
   return (a + b + fabs(a - b)) / 2.0;
}
\end{cppsource}

These branchless versions are now differentiable everywhere except when \textit{a - b} is zero, as the absolute value function \textit{fabs()} is not differentiable when the argument is zero.

\subsection{ATL}

The Analytics Template Library (ATL) is a general purpose C++ template metaprogramming library for scientific computing being developed by NOAA Fisheries. ATL has a reverse mode automatic differentiation module that can compute higher-order mixed derivatives up to the 3rd order. In ATL, the \textit{fabs(x)} function is not differentiable when \textit{x} is zero, thus the \textit{min()} and \textit{max()} functions are not differentiable when \textit{a - b} is zero. The code for \textit{min()} and \textit{max()} in ATL:

\begin{cppsource}

/**
 * Returns the minimum of a and b in a branchless manner using:
 *
 * (a + b - |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
template <typename T>
inline const atl::Variable<T> min(const atl::Variable<T>& a,
	const atl::Variable<T>& b) {
    return (a + b - atl::fabs(a - b)) / 2.0;
}

/**
 * Returns the maximum of a and b in a branchless manner using:
 *
 * (a + b + |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
template <typename T>
inline const atl::Variable<T> max(const atl::Variable<T>& a,
	const atl::Variable<T>& b) {
    return (a + b + atl::fabs(a - b)) / 2.0;
}


\end{cppsource}


\subsection{ADMB}

Unlike ATL, the \textit{fabs(x)} function in ADMB always returns a derivative value even if x is zero. In ADMB, if x is greater than or equal to zero, the resulting derivative is 1, otherwise it is -1.  The ADMB code for \textit{min()} and \textit{max()}:

\begin{cppsource}

/**
 * Returns the maximum between a and b in a continuous manner using:
 *
 * (a + b + |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
inline prevariable& max(const dvariable& a, const dvariable& b) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = (a + b + fabs(a - b)) / 2.0;
    return *gradient_structure::RETURN_PTR;
}


/**
 * Returns the minimum between a and b in a continuous manner using:
 *
 * (a + b - |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
inline prevariable& min(const dvariable& a, const dvariable& b) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = (a + b - fabs(a - b)) / 2.0;
    return *gradient_structure::RETURN_PTR;
}

\end{cppsource}


%\section{Validation and Verification}

\section{Discussion}

The differences in the ATL and ADMB versions of the \textit{min()} and \textit{max()} functions arise from the implementation of \textit{fabs(x)}. ATL will return a derivative value of \textit{nan} when \textit{a - b} is zero. This is because the derivative of the absolute value function is undefined at zero. However, ADMB will return a derivative value of 1 when x is zero. We suggest a discussion on which method is more robust for fisheries science applications, and ask for contributions from the broader community for guidance.

\section{References}

\section{Appendix A: ATL Example Source Code}

\begin{cppsource}

/**
 * Returns the minimum of a and b in a branchless manner using:
 *
 * (a + b - |a - b)|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
template <typename T>
inline const atl::Variable<T> ad_min(const atl::Variable<T>& a,
const atl::Variable<T>& b) {
    return (a + b - atl::fabs((a - b))) / 2.0;
}

/**
 * Returns the maximum of a and b in a branchless manner using:
 *
 * (a + b + |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
template <typename T>
inline const atl::Variable<T> max(const atl::Variable<T>& a,
 const atl::Variable<T>& b) {
    return (a + b + atl::fabs(a - b)) / (2.0);
}


inline const atl::Variable<double> ad_normalize_and_sum(
std::vector<atl::Variable<double> >& v) {
    atl::Variable<double> maxv = v[0];
    for (int i = 1; i < v.size(); i++) {
        maxv = max(maxv, v[i]);
    }

    for (int i = 0; i < v.size(); i++) {
        v[i] /= maxv;
    }

    atl::Variable<double> sum;
    for (int i = 0; i < v.size(); i++) {
        sum += v[i];
    }

    return sum;
}
\end{cppsource}

\begin{cppsource}

inline const atl::Variable<double> ad_min_max_test(int nvar,
std::vector<atl::Variable<double> >& x) {
    std::vector<atl::Variable<double> > X(nvar, atl::Variable<double>());
    for (int i = 0; i < x.size(); i++) {
        X[i] = atl::Variable<double>(x[i] * x[i]);
    }
    return ad_normalize_and_sum(X);
}

/*
 *
 */
int main(int argc, char** argv) {

    std::vector<atl::Variable<double> > x(10);
    for (int i = 0; i < x.size(); i++) {
        x[i] = (double) (i + 1);
    }

    atl::Variable<double> ret = ad_min_max_test(x.size(), x);

    atl::Variable<double>::tape.Accumulate();

    std::cout << "Gradient:\n";
    for (int i = 0; i < x.size(); i++) {
        std::cout <<
        atl::Variable<double>::tape.first_order_derivatives[x[i].info->id] << " ";
    }
    return 0;
}

\end{cppsource}

\textbf{Output}
\begin{myoutput}
Gradient:
0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 -0.57
\end{myoutput}

\section{Appendix B: ADMB Example Source Code}

\begin{cppsource}
/**
 * Returns the minimum of a and b in a branchless manner using:
 *
 * (a + b - |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
inline prevariable& min(const dvariable& a, const dvariable& b) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = (a + b - fabs(a - b)) / (2.0);
    return *gradient_structure::RETURN_PTR;
}

/**
 * Returns the maximum of a and b in a branchless manner using:
 *
 * (a + b + |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
inline prevariable& max(const dvariable& a, const dvariable& b) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = (a + b + fabs(a - b)) / (2.0);
    return *gradient_structure::RETURN_PTR;
}

const dvariable ad_normalize_and_sum(std::vector<dvariable>& v) {
    dvariable maxd = v[0];
    for (int i = 1; i < v.size(); i++) {
        maxd = max(maxd, v[i]);
    }

    for (int i = 0; i < v.size(); i++) {
        v[i] /= maxd;
    }

    dvariable sum;
    for (int i = 0; i < v.size(); i++) {
        sum += v[i];
    }

    return sum;
}
\end{cppsource}

\begin{cppsource}
inline const dvariable ad_min_max_test(int nvar, dvar_vector x) {
    std::vector<dvariable> X(nvar);
    for (int i = 0; i < X.size(); i++) {
        X[i] = x(i + 1) * x(i + 1);
    }
    return ad_normalize_and_sum(X);
}

int main(int argc, char** argv) {

    int nvar = 10;
    gradient_structure::set_MAX_NVAR_OFFSET(nvar);
    gradient_structure gs(800000000L);

    dvector g(1, nvar);
    independent_variables x(1, nvar);
    for (int i = 1; i <= nvar; i++) {
        x(i) = (double) i;
    }

    dvariable ret = ad_min_max_test(nvar, x);

    gradcalc(nvar, g); // The derivatives are calculated
    cout << "Gradient:\n" << g << "\n";
    return 0;
}
\end{cppsource}

\textbf{Output}
\begin{myoutput}
Gradient:
0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 -0.57
\end{myoutput}

\end{document}
