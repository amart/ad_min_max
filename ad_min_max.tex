%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Journal Article
% LaTeX Template
% Version 1.3 (9/9/13)
%
% This template has been downloaded from:
% http://www.LaTeXTemplates.com
%
% Original author:
% Frits Wenneker (http://www.howtotex.com)
%
% License:
% CC BY-NC-SA 3.0 (http://creativecommons.org/licenses/by-nc-sa/3.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[oneside]{article}

\usepackage{lipsum} % Package to generate dummy text throughout this template
\usepackage{sectsty}
\sectionfont{\bfseries\Large\raggedright}
\usepackage[printwatermark]{xwatermark}
\newwatermark[allpages,color=red!50,angle=45,scale=3,xpos=0,ypos=0]{DRAFT}
\usepackage{makecell}
\usepackage{pgfplots}
\usepackage{color}
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    linktoc=all,
    citecolor=blue,
    filecolor=blue,
    linkcolor=blue,
    urlcolor=blue
}
\usepackage{titlesec}

\setcounter{secnumdepth}{4}
\setcounter{tocdepth}{4}
\usepackage{listings}
\usepackage{xcolor}
\lstset { %
    language=C++,
    backgroundcolor=\color{black!5}, % set backgroundcolor
    basicstyle=\footnotesize,% basic font setting
}

\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{forest}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{adjustbox}

\newsavebox{\mysavebox}
\newlength{\myrest}
\usepackage{fix-cm}
\usepackage{algorithm,algpseudocode,float}
\usepackage{lipsum}
\newcommand{\Code}[1]{%
\lstinline{#1}}
\usepackage[T1]{fontenc}
\usepackage[many]{tcolorbox}
\tcbuselibrary{listings}

\newcommand{\Out}[1]{%
\begin{lstlisting}[language=bash]
#1
\end{lstlisting}
}
\newtcblisting{cppsource}{
  colback=white,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  top=0pt,
  bottom=0pt,
  colframe=white,
  listing only,
 left=15.5pt,
  enhanced,
  listing options={
    columns=flexible,
    basicstyle=\small\ttfamily,
    keywordstyle=\color{blue},
    backgroundcolor=\color{black!4}, % set backgroundcolor
    language=C++,
    showstringspaces=false,
    tabsize=2,
  }
}
\newtcblisting{smallcppsource}{
  colback=white,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  top=0pt,
  bottom=0pt,
  colframe=white,
  listing only,
 left=15.5pt,
  enhanced,
  listing options={
    columns=flexible,
    basicstyle=\tiny\ttfamily,
    keywordstyle=\color{blue},
    backgroundcolor=\color{black!4}, % set backgroundcolor
    language=C++,
    showstringspaces=false,
    tabsize=2,
  }
}

\newtcblisting{myoutput}{
  colback=white,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  top=0pt,
  bottom=0pt,
  colframe=white,
  listing only,
  listing options={
    basicstyle=\scriptsize\ttfamily\color{black},
    breaklines=false,
    columns=flexible,
     backgroundcolor=\color{white}, % set backgroundcolor
%    language=bash,
  }
}


\newtcblisting{editnote}{
  colback=white,
  boxrule=0pt,
  arc=0pt,
  outer arc=0pt,
  top=0pt,
  bottom=0pt,
  colframe=white,
  listing only,
  listing options={
    basicstyle=\scriptsize\ttfamily,
    breaklines=false,
    columns=flexible,
     backgroundcolor=\color{white}, % set backgroundcolor
    language=bash,
  }
}

\usepackage[sc]{mathpazo} % Use the Palatino font
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage{multicol} % Used for the two-column layout of the document
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{abstract} % Allows abstract customization
\renewcommand{\abstractnamefont}{\normalfont\bfseries} % Set the "Abstract" text to bold
\renewcommand{\abstracttextfont}{\normalfont\small\itshape} % Set the abstract itself to small italic text

\usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
%\titleformat{\section}[block]{\large\scshape\centering}{\thesection.}{1em}{} % Change the look of the section titles
%\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the section titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{NOAA, Office Of Science and Technology, National Modeling and Assessment Team \\ Internal Document $\bullet$ December 2016 } % Custom header text
%    \fancyfoot[RO,LE]{\thepage} % Custom footer text



%----------------------------------------------------------------------------------------
%	TITLE SECTION
%----------------------------------------------------------------------------------------

\title{\vspace{-15mm}\fontsize{24pt}{24pt}\selectfont\textbf{Notes On \protect\\  Implementing Differentiable  \protect\\ Minimum And Maximum Functions \protect\\
In \protect\\
ATL and  ADMB}} % Article title

\author{
\large
\textsc{Matthew R. Supernaw}\\[2mm] % Your name
\normalsize National Oceanic Atmospheric Administration \\ % Your institution
\normalsize National Marine Fisheries Service, Office of Science and Technology\\ % Your institution
\normalsize \href{mailto:matthew.supernaw@noaa.gov}{matthew.supernaw@noaa.gov} \\ % Your email address
\\
\textsc{Z. Teresa A'mar, PhD}\\[2mm] % Your name
\normalsize National Oceanic Atmospheric Administration \\ % Your institution
\normalsize National Marine Fisheries Service, Office of Science and Technology\\ % Your institution
\normalsize \href{mailto:teresa.amar@noaa.gov}{teresa.amar@noaa.gov} \\% Your email address
\vspace{-5mm}
}
\date{}

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Insert title

\thispagestyle{fancy} % All pages have headers and footers

%----------------------------------------------------------------------------------------
%	ABSTRACT
%----------------------------------------------------------------------------------------

%\begin{abstract}
%
%\noindent
%
%
%\end{abstract}

%----------------------------------------------------------------------------------------
%	ARTICLE CONTENTS
%----------------------------------------------------------------------------------------

\newpage
\tableofcontents
\newpage

\section{Introduction}

The "minimum" and "maximum" functions (usually written as \textit{min(a,b)} and \textit{max(a,b)}, respectively) are problematic for automatic differentiation systems. The issue is that existing \textit{min()} and \textit{max()} function implementations rely on conditional statements, or branches, to calculate the return value. This method results in a piecewise continuous function which is not generally differentiable.  In this paper we describe a method so that the \textit{min()} and \textit{max()} functions with two automatic differentiation variable types as arguments can be calculated with no branching, thereby preserving the derivatives of the variables. In addition, we describe how these functions can be implemented in Analytics Template Library (ATL) and AD Model Builder (ADMB).


\section{Methods}

Given two variables \textit{a} and \textit{b}, calculate the minimum or maximum value. Existing implementations can involve conditional operations, i.e., "if" statements are used to determine the return value:

\begin{cppsource}
template<typename T>
T min(const T& a, const T& b){
   return a < b ? a : b;
}

template<typename T>
T max(const T& a, const T& b){
   return a > b ? a : b;
}

\end{cppsource}

These functions do not work in an automatic differentiation system since the functions are not differentiable everywhere given the branching in the code.

A common branchless alternative can be used:

\begin{cppsource}
template<typename T>
T min(const T& a, const T& b){
   return (a + b - fabs(a - b)) / 2.0;
}

template<typename T>
T max(const T& a, const T& b){
   return (a + b + fabs(a - b)) / 2.0;
}
\end{cppsource}

These branchless versions are now differentiable everywhere except where the argument is zero, as the absolute value function \textit{fabs(x)} is not differentiable when the argument is zero.

\subsection{ATL}

The Analytics Template Library (ATL) is a general purpose C++ template metaprogramming library for scientific computing being developed by NOAA Fisheries. ATL has a reverse mode automatic differentiation module that can compute higher-order mixed derivatives up to the 3rd order. In ATL, the \textit{fabs(x)} function is not differentiable when the argument is zero, thus the \textit{min()} and \textit{max()} functions are not differentiable where \textit{a - b} is zero.

The ATL code for \textit{min()} and \textit{max()}:

\begin{cppsource}

/**
 * Returns the minimum of a and b in a branchless manner using:
 *
 * (a + b - |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
template <typename T>
inline const atl::Variable<T> min(const atl::Variable<T>& a,
	const atl::Variable<T>& b) {
    return (a + b - atl::fabs(a - b)) / 2.0;
}

/**
 * Returns the maximum of a and b in a branchless manner using:
 *
 * (a + b + |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
template <typename T>
inline const atl::Variable<T> max(const atl::Variable<T>& a,
	const atl::Variable<T>& b) {
    return (a + b + atl::fabs(a - b)) / 2.0;
}


\end{cppsource}


\subsection{ADMB}

AD Model Builder (ADMB) is a C++ library which implements automatic differentiation using specialized classes and operator overloading. \cite{ admb} Unlike ATL, the \textit{fabs(x)} function in ADMB always returns a derivative value even if the argument is zero. In ADMB, if the argument is greater than or equal to zero, the resulting derivative is 1, otherwise it is -1. ADMB documentation notes that the \textit{fabs(x)} function is a simple overload of the standard C library function, which is "not differentiable and should not be used in cases where an independent variable is expected to change sign." However, ADMB offers an alternative function \textit{sfabs(x)}. This function is described as the smooth absolute value and uses a third order polynomial to interpolate for values within the range (-0.001, 0.001). Derivatives are correct for all arguments which are not equal to zero. This code will result in a derivative of zero when the argument is zero

The ADMB code for \textit{min()} and \textit{max()}:

\begin{cppsource}

/**
 * Returns the maximum between a and b in a continuous manner using:
 *
 * (a + b + |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
inline prevariable& max(const dvariable& a, const dvariable& b) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = (a + b + sfabs(a - b)) / 2.0;
    return *gradient_structure::RETURN_PTR;
}


/**
 * Returns the minimum between a and b in a continuous manner using:
 *
 * (a + b - |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
inline prevariable& min(const dvariable& a, const dvariable& b) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = (a + b - sfabs(a - b)) / 2.0;
    return *gradient_structure::RETURN_PTR;
}

\end{cppsource}



\section{Discussion}

The differences in the ATL and ADMB versions of the \textit{min()} and \textit{max()} functions arise from the implementation of \textit{fabs(x)} and \textit{sfabs(x)}.  ATL will return a derivative value of \textit{nan} when the argument is zero. This is because the analytical derivative of the absolute value function is undefined at zero. However, ADMB will return a derivative value of 0 when the argument is zero. An alternative to \textit{atl::fabs(x)} and \textit{sfabs(x)} can be used.

The code for the ATL version:


\begin{cppsource}
 /**
     * Evaluates pow((expr*expr)+C, .5).
     * 
     * Used when expr could evaluate to zero.
     * 
     * @param expr
     * @param C default = std::numeric_limits< double >::denorm_min()
     * @return 
     */
    template<class REAL_T, class EXPR>
    const atl::Variable<REAL_T> ad_fabs(const atl::ExpressionBase<REAL_T, EXPR>& expr,
     REAL_T C = std::numeric_limits< REAL_T >::denorm_min()) {
        return atl::pow((expr * expr) + C, .5);
    }

\end{cppsource}

And for ADMB:

\begin{cppsource}
/**
 * Evaluates pow((x*x)+C, .5).
 * 
 * Used when x could evaluate to zero.
 * 
 * @param x
 * @param C default = std::numeric_limits< double >::denorm_min()
 * @return 
 */
inline prevariable& ad_fabs(const dvariable& x, 
double C = std::numeric_limits< double >::denorm_min()) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = pow((x * x) + C, .5);
    return *gradient_structure::RETURN_PTR;
}

\end{cppsource}

In the above code listings, a very small constant is added to keep the derivative of the absolute value of \textit{x} from being undefined. This small value is enough to keep the derivatives from returning \textit{nan} when \textit{x} is zero, while having little effect on gradient-based optimization routines.    

We suggest a discussion of which method is more robust for fisheries science applications, and ask for contributions from the broader community for guidance.

\section{References}
\begin{thebibliography}{9}

\bibitem{admb} 
Fournier, D.A., Skaug, H.J., Ancheta, J., Ianelli, J., Magnusson, A., Maunder, M.N., Nielsen, A., and Sibert, J. 2012.
\textit{AD Model Builder: using automatic differentiation for statistical inference of highly parameterized complex nonlinear models.}
\textit{Optim. Methods Softw. 27:233-249.}

\end{thebibliography}
\section{Appendix A: ATL Example Source Code}

\begin{cppsource}

/**
 * Returns the minimum of a and b in a branchless manner using:
 *
 * (a + b - |a - b)|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
template <typename T>
inline const atl::Variable<T> ad_min(const atl::Variable<T>& a,
const atl::Variable<T>& b) {
    return (a + b - ad_fabs((a - b))) / 2.0;
}

/**
 * Returns the maximum of a and b in a branchless manner using:
 *
 * (a + b + |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
template <typename T>
inline const atl::Variable<T> max(const atl::Variable<T>& a,
 const atl::Variable<T>& b) {
    return (a + b + ad_fabs(a - b)) / (2.0);
}


inline const atl::Variable<double> ad_normalize_and_sum(
std::vector<atl::Variable<double> >& v) {
    atl::Variable<double> maxv = v[0];
    for (int i = 1; i < v.size(); i++) {
        maxv = max(maxv, v[i]);
    }

    for (int i = 0; i < v.size(); i++) {
        v[i] /= maxv;
    }

    atl::Variable<double> sum;
    for (int i = 0; i < v.size(); i++) {
        sum += v[i];
    }

    return sum;
}
\end{cppsource}

\begin{cppsource}

inline const atl::Variable<double> ad_min_max_test(int nvar,
std::vector<atl::Variable<double> >& x) {
    std::vector<atl::Variable<double> > X(nvar, atl::Variable<double>());
    for (int i = 0; i < x.size(); i++) {
        X[i] = atl::Variable<double>(x[i] * x[i]);
    }
    return ad_normalize_and_sum(X);
}

/*
 *
 */
int main(int argc, char** argv) {

    std::vector<atl::Variable<double> > x(10);
    for (int i = 0; i < x.size(); i++) {
        x[i] = (double) (i + 1);
    }

    atl::Variable<double> ret = ad_min_max_test(x.size(), x);

    atl::Variable<double>::tape.Accumulate();

    std::cout << "Gradient:\n";
    for (int i = 0; i < x.size(); i++) {
        std::cout <<
        atl::Variable<double>::tape.first_order_derivatives[x[i].info->id] << " ";
    }
    return 0;
}

\end{cppsource}

\textbf{Output}
\begin{myoutput}
Gradient:
0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 -0.57
\end{myoutput}

\section{Appendix B: ADMB Example Source Code}

\begin{cppsource}
/**
 * Returns the minimum of a and b in a branchless manner using:
 *
 * (a + b - |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
inline prevariable& min(const dvariable& a, const dvariable& b) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = (a + b - ad_fabs(a - b)) / (2.0);
    return *gradient_structure::RETURN_PTR;
}

/**
 * Returns the maximum of a and b in a branchless manner using:
 *
 * (a + b + |a - b|) / 2.0;
 *
 * @param a
 * @param b
 * @return
 */
inline prevariable& max(const dvariable& a, const dvariable& b) {
    if (++gradient_structure::RETURN_PTR > gradient_structure::MAX_RETURN)
        gradient_structure::RETURN_PTR = gradient_structure::MIN_RETURN;

    *gradient_structure::RETURN_PTR = (a + b + ad_fabs(a - b)) / (2.0);
    return *gradient_structure::RETURN_PTR;
}

const dvariable ad_normalize_and_sum(std::vector<dvariable>& v) {
    dvariable maxd = v[0];
    for (int i = 1; i < v.size(); i++) {
        maxd = max(maxd, v[i]);
    }

    for (int i = 0; i < v.size(); i++) {
        v[i] /= maxd;
    }

    dvariable sum;
    for (int i = 0; i < v.size(); i++) {
        sum += v[i];
    }

    return sum;
}
\end{cppsource}

\begin{cppsource}
inline const dvariable ad_min_max_test(int nvar, dvar_vector x) {
    std::vector<dvariable> X(nvar);
    for (int i = 0; i < X.size(); i++) {
        X[i] = x(i + 1) * x(i + 1);
    }
    return ad_normalize_and_sum(X);
}

int main(int argc, char** argv) {

    int nvar = 10;
    gradient_structure::set_MAX_NVAR_OFFSET(nvar);
    gradient_structure gs(800000000L);

    dvector g(1, nvar);
    independent_variables x(1, nvar);
    for (int i = 1; i <= nvar; i++) {
        x(i) = (double) i;
    }

    dvariable ret = ad_min_max_test(nvar, x);

    gradcalc(nvar, g); // The derivatives are calculated
    cout << "Gradient:\n" << g << "\n";
    return 0;
}
\end{cppsource}

\textbf{Output}
\begin{myoutput}
Gradient:
0.02 0.04 0.06 0.08 0.1 0.12 0.14 0.16 0.18 -0.57
\end{myoutput}

\end{document}
